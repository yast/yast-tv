/**
 * File:
 *   UniqueKeys.ycp
 *
 * Package:
 *   Library for configuration of pieces of hardware
 *
 * Summary:
 *   A Module:: for handling /var/lib/YaST/unique.inf and special comments
 *   in /etc/modules.conf
 *
 * Authors:
 *   Jan Holesovsky <kendy@suse.cz>
 *
 * $Id$
 *
 * Functions for handling /var/lib/YaST/unique.inf and special comments
 * in /etc/modules.conf
 *
 */

{
    module "UniqueKeys";

    /**
     * Reads the given section of the unique.inf.
     * @param section The piece of hardware you configure.
     * @return list A list of the unique keys of the installed TV cards
     * @example
     *    UniqueKeys::ReadSection ( "network" );
     * -> [ $[ "state" : "configured",
     *         "unique":"AZlZ.TKxDWpk5UB7"
     *      ]
     *    ]
     */
    global define list ReadSection (string section) ``{
	// Read the necessary info
	list unique_inf = SCR::Read ( .var.lib.yast.unique );
	if (unique_inf == nil)
	{
	    return [];
	}

	// filter out the other sections
	unique_inf = filter ( `entry, unique_inf,
			      ``( lookup (entry, "section", "") == section ) );
	map first_section = select ( unique_inf, 0, $[] );

	return lookup ( first_section, "contents", [] );
    }

    /**
     * Write the given section of the unique.inf.
     * @param section The piece of hardware you configure.
     * @param contents List of maps with keys "state" and "unique".
     * @return boolean Success?
     * @example
     *    UniqueKeys::WriteSection ( "network",
     *                               [ $[ "state" : "configured",
     *                                    "unique":"AZlZ.TKxDWpk5UB7" ]
     *                               ] );
     */
    global define boolean WriteSection (string section, list contents) ``{
	// Read the necessary info
	list unique_inf = SCR::Read ( .var.lib.yast.unique );
	if (unique_inf == nil)
	{
	    unique_inf = [];
	}

	// filter out the old section
	unique_inf = filter ( `entry, unique_inf,
			      ``( lookup ( entry, "section", "" ) != section ) );

	// add the given section
	if (contents != nil && contents != [])
	{
	    map val = $[ "section" : section, "contents" : contents ];
	    unique_inf = add ( unique_inf, val );
	    // Some day: change(unique_inf, val);
	}

	boolean result = SCR::Write(.var.lib.yast.unique, unique_inf);
	if (!result)
	{
	    y2error("Unable to write unique.inf: %1", unique_inf);
	}

	return result;
    }

    /**
     * Create comment for modules.conf from the unique key and the name
     * of the card. It will be parsed when reading.
     * This comment should be placed before the alias differentiating
     * the card (char-major-81-x for TV cards, ethx for ethernet, ...)
     * @param name Name of the card
     * @param unique_key Unique key
     * @return string The comment.
     * @example
     *    UniqueKeys::StoreToComment ("Ultra brutal TV card", "xyza.aiLKJkjsdlj")
     * -> "# xyza.aiLKJkjsdlj:Ultra brutal TV card\n"
     */
    global define string StoreToComment (string name, string unique_key) ``{
	if (name == nil)
	{
	    name = "Unknown card";
	}
	if (unique_key == nil)
	{
	    unique_key = "uniq.key";
	}

	return sformat ( "# %1:%2\n", unique_key, name );
    }

    /**
     * Extacts the unique key and the name of the card from comment in the
     * modules.conf placed before the alias differentiatin the card.
     * @param comment The comment
     * @return map Returns map: $[ "unique_key" : string, "name" : string ]
     * @example
     *    UniqueKeys::ExtractFromComment ("# xyza.aiLKJkjsdlj:Ultra brutal TV card\n")
     * -> $[ "name" : "Ultra brutal TV card", "unique_key" : "xyza.aiLKJkjsdlj" ]
     */
    global define map ExtractFromComment(string comment) ``{
	if (comment == nil)
	{
	    comment = "";
	}

	map result = $[ "name" : "", "unique_key" : "" ];

	// split to lines
	list comment_lines = splitstring(comment, "\n");

	// find last line with a ":"
	string line_with_uk = "";
	integer colon_pos_uk = nil;
	foreach(`line, comment_lines, ``{
	    integer c_pos = findfirstof(line, ":");
	    if (c_pos != nil)
	    {
		line_with_uk = line;
		colon_pos_uk = c_pos;
	    }
	});

	// did we find it?
	if (colon_pos_uk != nil)
	{
	    // extract name
	    string name = substring(line_with_uk,
				    colon_pos_uk + 1,
				    size(line_with_uk) - colon_pos_uk - 1);
	    // extract unique key
	    integer start_uk = findfirstnotof(line_with_uk, "# \t");
	    string uk = substring(line_with_uk,
				  start_uk,
				  colon_pos_uk - start_uk);

	    result = $[ "name" : name, "unique_key" : uk ];
	}

	return result;
    }

}
