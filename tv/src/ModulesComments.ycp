/**
 * File:	modules/ModulesComments.ycp
 * Package:	TV cards configuration
 * Summary:	Library for handling special comments in /etc/modules.conf
 * Authors:	Jan Holesovsky <kendy@suse.cz>
 *
 * $Id$
 *
 * Functions for handling special comments in /etc/modules.conf
 */

{

    module "ModulesComments";

    /**
     * Create comment for modules.conf from the unique key and the name
     * of the card. It will be parsed when reading.
     * This comment should be placed before the alias differentiating
     * the card (char-major-81-x for TV cards, ethx for ethernet, ...)
     * @param name Name of the card
     * @param unique_key Unique key
     * @return string The comment.
     * @example
     *    ModulesComments::StoreToComment ("Ultra brutal TV card", "xyza.aiLKJkjsdlj")
     * -> "# xyza.aiLKJkjsdlj:Ultra brutal TV card\n"
     */
    global define string StoreToComment (string name, string unique_key) ``{
	if (name == nil)
	{
	    name = "Unknown card";
	}
	if (unique_key == nil)
	{
	    unique_key = "uniq.key";
	}

	return sformat ( "# %1:%2\n", unique_key, name );
    }

    /**
     * Extacts the unique key and the name of the card from comment in the
     * modules.conf placed before the alias differentiatin the card.
     * @param comment The comment
     * @return map Returns map: $[ "unique_key" : string, "name" : string ]
     * @example
     *    ModulesComments::ExtractFromComment ("# xyza.aiLKJkjsdlj:Ultra brutal TV card\n")
     * -> $[ "name" : "Ultra brutal TV card", "unique_key" : "xyza.aiLKJkjsdlj" ]
     */
    global define map ExtractFromComment(string comment) ``{
	if (comment == nil)
	{
	    comment = "";
	}

	map result = $[ "name" : "", "unique_key" : "" ];

	// split to lines
	list comment_lines = splitstring(comment, "\n");

	// find last line with a ":"
	string line_with_uk = "";
	integer colon_pos_uk = nil;
	foreach(string line, (list<string>) comment_lines, ``{
	    integer c_pos = findfirstof(line, ":");
	    if (c_pos != nil)
	    {
		line_with_uk = line;
		colon_pos_uk = c_pos;
	    }
	});

	// did we find it?
	if (colon_pos_uk != nil)
	{
	    // extract name
	    string name = substring(line_with_uk,
				    colon_pos_uk + 1,
				    size(line_with_uk) - colon_pos_uk - 1);
	    // extract unique key
	    integer start_uk = findfirstnotof(line_with_uk, "# \t");
	    string uk = substring(line_with_uk,
				  start_uk,
				  colon_pos_uk - start_uk);

	    result = $[ "name" : name, "unique_key" : uk ];
	}

	return result;
    }

/* EOF */
}
